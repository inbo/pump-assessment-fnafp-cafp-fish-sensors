---
title: "bds_shear"
author: "Sarah Broos"
date: "2024-09-30"
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r setup, echo=TRUE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
```

```{r}
# import libraries from file
source("./source/not_functions/libraries.R")
source("./source/functions/correct_ROI_manually.R")
```

```{r}
if (file.exists("./data/bds/internal/Manually_changed_ROI.csv")) {
 unlink("./data/bds/internal/Manually_changed_ROI.csv")
 print("File is deleted..")
} else{
 print("File not exists..")
}
```

# Read in data, correct column names if necessary and rbind into 1 file

```{r}
if (file.exists("data/bds/internal/All_BDS_data_OK.csv")==FALSE){
  list.dir<-list.dirs(path = "./data/bds/external/")
  for (i in 2:length(list.dir)){
    list.file<-list.files(path=list.dir[[i]], pattern=".csv", all.files=TRUE,full.names=TRUE)
    for (j in 1:length(list.file)){
      file.temp<-read.csv(list.file[j])
      if (any(colnames(file.temp)=="Time..ms.")){colnames(file.temp)[which(names(file.temp) == "Time..ms.")] <- "Time..s."}
      if (any(colnames(file.temp)=="AX..m.s2.")){colnames(file.temp)[which(names(file.temp) == "AX..m.s2.")] <- "AXEarth..m.s2."}
      if (any(colnames(file.temp)=="AY..m.s2.")){colnames(file.temp)[which(names(file.temp) == "AY..m.s2.")] <- "AYEarth..m.s2."}
      if (any(colnames(file.temp)=="AZ..m.s2.")){colnames(file.temp)[which(names(file.temp) == "AZ..m.s2.")] <- "AZEarth..m.s2."}
      file.temp$scenario<-str_split(list.file[j],"/")[[1]][5]
      file.temp$sensor<-gsub(".csv","",str_split(list.file[j],"/")[[1]][6])
      file.temp$scenario_sensor<-paste(file.temp$scenario,file.temp$sensor,sep="/")
      if (j==1){file=file.temp} 
      if (j>1){file=smartbind(file,file.temp)}
    }
    if (i==2){file.complete=file} 
    if (i>2){file.complete=smartbind(file.complete,file)}
  }
  file.complete <- file.complete[which(file.complete$Time..s.<100),]
  write.csv(file.complete,"data/bds/internal/All_BDS_data_OK.csv")
} else {file.complete<-read.csv("data/bds/internal/All_BDS_data_OK.csv")}
rm(file.temp)
```


# Create new variables

To identify ROIs, the average pressure (average of the measurements in the three spatial dimensions) was used (unless explicitly mentioned otherwise).

```{r}
file.final <- file.complete

rm(file.complete)

file.final$scenario[which(file.final$scenario=="Old_Axial_n_6")]<-"CAFP"
file.final$scenario[which(file.final$scenario=="Pump_40Hz_Control_n_13")]<-"FNAFP - 468 rpm Ctrl"
file.final$scenario[which(file.final$scenario=="Pump_40Hz_n_64")]<-"FNAFP - 468 rpm"
file.final$scenario[which(file.final$scenario=="Pump_47Hz_Control_n_15")]<-"FNAFP - 550 rpm Ctrl"
file.final$scenario[which(file.final$scenario=="Pump_47Hz_n_51")]<-"FNAFP - 550 rpm"


file.final$P..hPa.<-rowMeans(file.final[,c("PC..hPa.","PR..hPa.","PL..hPa.")],na.rm=TRUE)
  
file.final <- file.final %>%
  group_by(sensor) %>%                  
  mutate(diff_sec = P..hPa. - lag(P..hPa.,n=1),
         diff_sec_sgolayfilt = sgolayfilt(P..hPa.,2,11) - lag(sgolayfilt(P..hPa.,2,11),n=1),
         window.sd = rollapply(P..hPa.,11,sd,align='center',fill=NA)) %>% 
  ungroup()  
```

# Overview of scenarios

```{r}
file.final %>% group_by(scenario) %>% distinct(scenario, sensor) %>% count() %>% kable(caption="Number of sensors per scenario")
```


# Determine the moment of injection

The moment of injection was the first moment in time at which all three pressure measurements were higher than 1005 hPa.  

```{r}
file.final.injection <- file.final %>%                                
  group_by(sensor) %>%                  
  filter(PL..hPa. > 1005 & PC..hPa. > 1005 & PR..hPa. > 1005) %>%  
  slice(1) %>%                       
  ungroup()  

file.final.injection$stage <- 'injection'
```

# Assess whether there are any sensors that were not given an injection moment

Due to faulty PL measurements, 5 sensors were not assigned a moment of injection. 

```{r}
sensors.without.injection <- unique(file.final$sensor)[which(unique(file.final$sensor) %in% unique(file.final.injection$sensor)==FALSE)]
sensors.without.injection

if (length(sensors.without.injection)>=1){

  for (i in sensors.without.injection){
    file.final.temp<-file.final[which(file.final$sensor==i),]
    g<-ggplot(file.final.temp,aes(x=Time..s.,y=P..hPa.))+geom_line()+theme_minimal()+ggtitle(i)
    print(g)
    rm(file.final.temp)
  }
  
  file.final.injection.extra <- file.final %>%  
    filter(sensor %in% sensors.without.injection) %>% 
    group_by(sensor) %>%                  
    filter(PC..hPa. > 1005 & PR..hPa. > 1005) %>%  
    slice(1) %>%                       
    ungroup() 
  
  file.final.injection.extra$stage <- 'injection'
  
  file.final.injection <- rbind(file.final.injection,file.final.injection.extra)
  
  sensors.without.injection <- unique(file.final$sensor)[which(unique(file.final$sensor) %in% unique(file.final.injection$sensor)==FALSE)]
  print(sensors.without.injection)
  
  rm(sensors.without.injection,file.final.injection.extra)
}
```

# Assess whether the moment of injection is correct for all sensors and if not: correct

For these sensors without injection, the PL measurements were not considered when identifying the injection. After visual inspection all assigned injections were appropriately identified.

```{r}
sensors.with.unlikely.injection <- unique(file.final.injection$sensor[which(file.final.injection$Time..s.>100)])
sensors.with.unlikely.injection

if (length(sensors.with.unlikely.injection)>=1){

  file.final.injection.extra <- file.final %>%  
    filter(sensor %in% sensors.with.unlikely.injection) %>% 
    group_by(sensor) %>%                  
    filter(PC..hPa. > 1005 & PR..hPa. > 1005) %>%  
    slice(1) %>%                       
    ungroup() 
  
  file.final.injection.extra$stage <- 'injection'
  
  file.final.injection <- file.final.injection[-which(file.final.injection$sensor %in% unique(file.final.injection.extra$sensor)),]
  
  file.final.injection <- rbind(file.final.injection,file.final.injection.extra)
  
  sensors.with.unlikely.injection <- unique(file.final.injection$sensor[which(file.final.injection$Time..s.>100)])
  print(sensors.with.unlikely.injection)

  rm(file.final.injection.extra,sensors.with.unlikely.injection)
}
```

# Determine the moment of nadir pressure 

The nadir was determined differently for control and not-control sensors. For the non-control samples the nadir should be located within 3 and 75 seconds after the moment of injection. As the nadir is characterized by a sudden pressure change the relative change in average pressure should also be considered. To this end, a Savitzky-Golay smoothing filter was applied to the average pressure data over time with a filter polynomial order of 2 and frame length of 11. The nadir should be close in time (<0.1 seconds) to an absolute change in smoothed average pressure of minimally 20 hPa. The lowest value to meet these requirements was identified as the nadir. For the control samples, the nadir should be located within 5 and 75 seconds after the moment of injection. There was no requirement to smooth the data for the control samples and the lowest pressure was retained as the nadir. After visual inspection, no correction needed to be made for the nadir as all appeared to be identified correctly using these rules.

```{r}
sensors<-unique(file.final$sensor)
file.final$time.of.injection<-NA
file.final$relative.to.injection<-NA

for (i in sensors){
  time.of.injection<-file.final.injection$Time..s.[which(file.final.injection$sensor==i)]
  file.final$time.of.injection[which(file.final$sensor==i)]<-time.of.injection
  file.final$relative.to.injection[which(file.final$sensor==i)]<-file.final$Time..s.[which(file.final$sensor==i)]-time.of.injection
}

file.final.nadir.pressure <- file.final %>%
  group_by(sensor) %>%
  mutate(NadirNearby=case_when(str_detect(scenario,"Ctrl")==FALSE & relative.to.injection > 3
                   & relative.to.injection < 75
                   & abs(diff_sec_sgolayfilt) > 20 ~ TRUE,
                   str_detect(scenario,"Ctrl")==TRUE & relative.to.injection > 5
                   & relative.to.injection < 75 ~ TRUE, .default=FALSE)) %>%
  mutate(diff_nadir = map_dbl(Time..s., ~ min(abs(.x - Time..s.[NadirNearby])))) %>%
  filter(diff_nadir<10*0.01) %>%
  filter(P..hPa.==min(P..hPa.)) %>%
  slice(1) %>%
  select(-c(diff_nadir, NadirNearby)) %>%
  ungroup()

file.final.nadir.pressure<-correct_ROI_manually(file.final.nadir.pressure,"B470904140250",20.165,"nadir_pressure")

file.final.nadir.pressure$relative.to.injection<-NULL
file.final.nadir.pressure$time.of.injection<-NULL
file.final$relative.to.injection<-NULL

file.final.nadir.pressure$stage <- 'nadir_pressure'

rm(time.of.injection)
```


#remove time data 10s after NADIR moment en 1 s before injection
To excluded data from in the net and taking sensor out of the water

```{r}
# Initialize an empty dataframe to store the results
file.final2 <- data.frame()

# Loop through each sensor and append the filtered data
for (i in sensors) {
  # Calculate the trim value for the current sensor
  trim <- file.final.nadir.pressure$Time..s.[file.final.nadir.pressure$sensor == i] + 10
  # Filter the data for the current sensor and append it to file.final2
  file.final2 <- rbind(
    file.final2, 
    file.final %>%
      filter(sensor == i, Time..s. < trim))
}

# Optionally replace file.final with the appended data
file.final1 <- file.final

file.final <- file.final2

# Clean up
rm(file.final2)
```

#Create Shear stress dataframe
threshold value
Based on literature we know U needs to be between 5 and 15m/s? Therefore we made an Threshold value based on 5, 10 and 15 m/s. For the creation of the threshold value we made use of (url to Jeff's Github for excel file). 
In this excel file we used the T on the 12/12/2018 and 13/12/2018, which is 4,5°C (see paper)

The threshold (ε ≥ 500 s-1) for ΔP at 4,5 °C and:
U = 5m/s: ΔP = 3,45 hPa
U = 10m/s: ΔP = 4,86 hPa
U = 15m/s: ΔP = 5,95 hPa

```{r}
#Length sensor
L<- 0.01

#velocity 
U<- 5

#temperature at the day we did the BDS test
Temp.C. <- 4.5

#calculate temperature depended variables
rho <- (999.83952+16.945176*Temp.C.-0.0079870401*Temp.C.^2)/(1+0.01689785*Temp.C.)
µ <- (exp(-3.7188+((578.919)/(-137.546+Temp.C.+273.15))))/1000

#Calculate Reynolds number
Re = (rho*U *L)/µ


df_shear<-file.final %>% 
  select(c(sensor, scenario, scenario_sensor, Time..s., PC..hPa.,PR..hPa.,PL..hPa.,PL..hPa., P..hPa.)) %>% 
  group_by(sensor) %>%
  mutate(
    Prc..hPa. = abs(PC..hPa.- PR..hPa.), #difference in pressure between central and right sensor
    Plc..hPa. = abs(PC..hPa.- PL..hPa.), #difference in pressure between central and left sensor
    shearcr = (40*Prc..hPa.)/sqrt(Re), #Formula based on the equations from Archenbacks 
    shearcl = (40*Plc..hPa.)/sqrt(Re),
    straincr = shearcr/µ, #transformation to strain rate in orde to be able to compare to laboratory studies
    straincl = shearcl/µ,
    mean_strain = rowMeans(cbind(straincr, straincl),na.rm=TRUE )
    ) %>% 
    ungroup()  
```



# Check plots of Plc and Prc in function of time with the threshold values

```{r}
scenario<-unique(df_shear$scenario)
l <- list()
k = 0

# Define the threshold value in hPa
th5<-3.45
th10<-4.86
th15<-5.95



for (s in scenario){
  df_shear.scenario<-df_shear[which(df_shear$scenario==s),]
  sensors<-unique(df_shear.scenario$sensor)
  for (i in sensors){
    k = k+1
    df_shear.sensor<-df_shear.scenario[which(df_shear.scenario$sensor==i),]
    #create plot with 2 lines one for Plc and one for Prc
     g <- ggplot(df_shear.sensor, aes(x = Time..s.)) +
            geom_line(aes(y = P..hPa., color = "P")) +   # Total pressure
            geom_line(aes(y = Plc..hPa., color = "Plc")) +   # First line for Plc
            geom_line(aes(y = Prc..hPa., color = "Prc")) +   # Second line for Prc
            geom_hline(yintercept = th5, linetype = "dashed", color = "black", aes(label = "U = 5 m/s")) +  # Threshold line 5 m/s
            geom_hline(yintercept = th5, linetype = "dashed", color = "black", aes(label = "U = 10 m/s")) +  # Threshold line U = 10 m/s
            geom_hline(yintercept = th5, linetype = "dashed", color = "black", aes(label = "U = 15 m/s")) +  # Threshold line U = 15 m/s
            theme_minimal() +
            ggtitle(paste0(s, "/", i)) +
            scale_color_manual(name = "Legend", values = c("Plc" = "blue", "Prc" = "red", "th5" = "black", "th10" = "black","th15" = "black", "P" = "black"))  # Custom colors for each line
    l[[k]]<-ggplotly(g)
    rm(df_shear.sensor)
  }
  rm(df_shear.scenario)
}
l
```

Cut dataframe after pump passage and remove broken sensors
```{r}
df_shear<-df_shear %>% 
  filter(!sensor %in% c("B041211162237", "B291213114542", "B261213093722", "B121211152453", "B261212110906","B331213114742", "B261212134451", "B261212160554", "B301212134839", "B301212160904", "B421212135906", "B470904140250", "B251212110824", "B421212111410"))


# Overview of sample sizes after removing broken/weird sensors data

df_shear %>% group_by(scenario) %>% distinct(scenario, sensor) %>% count() %>% kable(caption="Number of sensors per scenario")
```


#visualize and create df of strain rate and time above threshold

```{r}
# Define a function to find intersection points between the strain rate and threshold
find_intersections <- function(time, strain, threshold) {
  intersections <- c()
  
  for (i in 1:(length(strain) - 1)) {
    if ((strain[i] < threshold && strain[i+1] >= threshold) || (strain[i] >= threshold && strain[i+1] < threshold)) {
      # Linear interpolation to find the exact crossing time
      slope <- (strain[i+1] - strain[i]) / (time[i+1] - time[i])
      intersection_time <- time[i] + (threshold - strain[i]) / slope
      intersections <- c(intersections, intersection_time)
    }
  }
  
  return(intersections)
}

# Iterate over each scenario and sensor to plot and analyze
scenario <- unique(df_shear$scenario)
l <- list()
k <- 0

# Threshold for strain rate
th <- 500

# Dataframe to store results
over_threshold_df <- data.frame(
  Scenario = character(),
  Sensor = character(),
  Start_Time = numeric(),
  End_Time = numeric(),
  Duration = numeric(),
  Avg_strain = numeric(),
  Max_strain = numeric(),
  stringsAsFactors = FALSE
)

for (s in scenario) {
  df_shear.scenario <- df_shear[which(df_shear$scenario == s), ]
  sensors <- unique(df_shear.scenario$sensor)
  
  for (i in sensors) {
    k <- k + 1
    df_shear.sensor <- df_shear.scenario[which(df_shear.scenario$sensor == i), ]
    
    # Sort the data by Time..s. to ensure chronological order
    df_shear.sensor <- df_shear.sensor %>% arrange(Time..s.)
    
    # Create the plot with the lines for strain rates
    g <- ggplot(df_shear.sensor, aes(x = Time..s.)) +
      geom_line(aes(y = straincr, color = "straincr")) +  
      geom_line(aes(y = straincl, color = "straincl")) +  
      geom_line(aes(y = mean_strain, color = "mean_strain")) +   
      geom_hline(yintercept = th, linetype = "dashed", color = "black", aes(label = "Threshold 500 s^-1")) +  # Threshold line
      theme_minimal() +
      ggtitle(paste0(s, "/", i)) +
      scale_color_manual(
        name = "Legend", 
        values = c("straincr" = "red", "straincl" = "green", "mean_strain" = "blue", "threshold" = "black")
      )  # Custom colors for each line
    
    l[[k]] <- ggplotly(g)
    
    # Find intersections where mean_strain crosses the threshold
    intersections <- find_intersections(df_shear.sensor$Time..s., df_shear.sensor$mean_strain, th)
    
    # Loop through intersections two at a time to calculate periods above threshold
    for (j in seq(1, length(intersections), by = 2)) {
      if (j + 1 <= length(intersections)) {
        start_time <- intersections[j]
        end_time <- intersections[j + 1]
        duration <- end_time - start_time
        
        # Find the index range corresponding to this time period
        idx_start <- which.min(abs(df_shear.sensor$Time..s. - start_time))
        idx_end <- which.min(abs(df_shear.sensor$Time..s. - end_time))
        
        # Calculate average and maximum strain during this period
        avg_mean_strain <- mean(df_shear.sensor$mean_strain[idx_start:idx_end], na.rm = TRUE)
        max_mean_strain <- max(df_shear.sensor$mean_strain[idx_start:idx_end], na.rm = TRUE)
        
        # Append the result to the dataframe
        over_threshold_df <- rbind(
          over_threshold_df, 
          data.frame(
            Scenario = s,
            Sensor = i,
            Start_Time = start_time,
            End_Time = end_time,
            Duration = duration,
            Avg_mean_strain = avg_mean_strain,
            Max_mean_strain = max_mean_strain,
            stringsAsFactors = FALSE
          )
        )
      }
    }
    
    rm(df_shear.sensor)
  }
  
  rm(df_shear.scenario)
}

# Output the result (Optional visualization, summary, etc.)
l

```

```{r}
over_threshold_df_sum<-over_threshold_df %>%
  group_by(Scenario, Sensor) %>% 
  summarise(
    Duration = sum(Duration),
    Avg_mean_strain = mean(Avg_mean_strain),
    Max_mean_strain = max(Max_mean_strain)
  )
  
ggplot(over_threshold_df_sum, aes(x = Scenario, y = Duration)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Boxplot of Duration for Each Scenario",
       x = "Scenario",
       y = "Time over threshold (s)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(over_threshold_df_sum, aes(x = Scenario, y = Avg_mean_strain)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Boxplot of avarage mean strain above threshold for Each Scenario",
       x = "Scenario",
       y = "avarage mean_strain above threshold (s-1)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(over_threshold_df_sum, aes(x = Scenario, y = Max_mean_strain)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Boxplot of Maximal mean strain for Each Scenario",
       x = "Scenario",
       y = "Maximal mean strain (s-1)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))



```
#Statiscal comparsion between the boxplots
```{r}
# ANOVA for Duration
anova_duration <- aov(Duration ~ Scenario, data = over_threshold_df)
anova_avg_strain <- aov(Avg_mean_strain ~ Scenario, data = over_threshold_df)
anova_max_strain <- aov(Max_mean_strain ~ Scenario, data = over_threshold_df)


# Extract residuals from the ANOVA model
shapiro.test(residuals(anova_duration))
shapiro.test(residuals(anova_avg_strain))
shapiro.test(residuals(anova_max_strain))


# Levene's test for equal variances
leveneTest(Duration ~ Scenario, data = over_threshold_df)
leveneTest(Avg_mean_strain ~ Scenario, data = over_threshold_df)
leveneTest(Max_mean_strain ~ Scenario, data = over_threshold_df)


#not normally distributed/ homogenity not ok -> non parametic test
# Kruskal-Wallis test for Duration
kruskal_duration <- kruskal.test(Duration ~ Scenario, data = over_threshold_df)
kruskal_duration

# Kruskal-Wallis test for Avg_mean_strain
kruskal_avg_strain <- kruskal.test(Avg_mean_strain ~ Scenario, data = over_threshold_df)
kruskal_avg_strain

# Kruskal-Wallis test for Max_mean_strain
kruskal_max_strain <- kruskal.test(Max_mean_strain ~ Scenario, data = over_threshold_df)
kruskal_max_strain


library(dunn.test)
options(width = 5000)


# Dunn's test for Duration
dunn_test_duration <- dunn.test(over_threshold_df$Duration, over_threshold_df$Scenario, method = "bonferroni")
print(dunn_test_duration)


# Dunn's test for Avg_mean_strain
dunn_test_avg_strain <- dunn.test(over_threshold_df$Avg_mean_strain, over_threshold_df$Scenario, method = "bonferroni")
print(dunn_test_avg_strain)

# Dunn's test for Max_mean_strain
dunn_test_max_strain <- dunn.test(over_threshold_df$Max_mean_strain, over_threshold_df$Scenario, method = "bonferroni")
print(dunn_test_max_strain)


```


#heat map for shear stress 
Need to adjust this make the time relative to the NADIR pressure

```{r}
library(patchwork)

# Generate individual plots for each scenario
plots <- list()  # Create an empty list to store plots

scenarios <- unique(df_shear$scenario)  # Get unique scenarios

# Loop through each scenario and create a heatmap plot
for (s in scenarios) {
  df_shear.scenario <- df_shear %>% filter(scenario == s)
  
  p <- ggplot(df_shear.scenario, aes(x = Time..s., y = sensor, fill = mean_strain)) +
    geom_tile() +
    scale_fill_gradientn(
      colors = c("blue", "yellow", "red"),  # Blue for low, yellow for medium, red for high
      values = scales::rescale(c(0, 500, max(df_shear$mean_strain, na.rm = TRUE))),
      limits = c(0, max(df_shear$mean_strain, na.rm = TRUE)),  # Ensure the scale matches your data
      oob = scales::squish  # Handle out-of-bounds values
    ) +
    theme_minimal() +
    labs(
      title = paste("Scenario:", s),  # Title specific to each scenario
      x = "Time (s)",
      y = "Sensor",
      fill = "Shear Stress (s⁻¹)"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  plots[[s]] <- p  # Add the plot to the list
}

# Combine the individual plots using patchwork
combined_plot <- ((plots[[1]] | plots[[2]]) / (plots[[3]] | plots[[4]])/plots[[5]]) + plot_layout(guides = "collect", axes = "collect")


# Display the combined plot
combined_plot

```


